# File dedicated to test real ACL use cases. This allow to test documentation
# exemple.

postgres:
  roles_query: null


acl_dict:
  # CONNECT ACL on database
  connect:
    inspect: |
      WITH d AS (
          SELECT
              (aclexplode(datacl)).grantee AS grantee,
              (aclexplode(datacl)).privilege_type AS priv
          FROM pg_catalog.pg_database
          WHERE datname = current_database()
      )
      SELECT NULL as namespace, r.rolname, TRUE as "full"
      FROM pg_catalog.pg_roles AS r
      JOIN d ON d.grantee = r.oid AND d.priv = 'CONNECT'
    grant: |
      GRANT CONNECT ON DATABASE {database} TO {role};
    revoke: |
      REVOKE CONNECT ON DATABASE {database} FROM {role};

  # CONNECT ACL on PUBLIC role database
  public:
    inspect: |
      -- Returns public if no ACLs are defined in this database.
      WITH
      acls AS (
          SELECT
              (aclexplode(datacl)).grantee AS grantee,
              (aclexplode(datacl)).privilege_type AS priv
          FROM pg_catalog.pg_database
          WHERE datname = current_database()
      ),
      static AS (
          SELECT NULL AS namespace, 'public' AS rolname
      )
      SELECT static.*, TRUE as "full" FROM static
      LEFT OUTER JOIN acls ON acls.grantee = 0
      WHERE acls.grantee IS NULL;
    revoke: |
      REVOKE CONNECT ON DATABASE {database} FROM {role}

  # SELECT on TABLES
  ro:
    inspect: |
      WITH
        def AS (
          SELECT
            nsp.oid, nsp.nspname,
            (aclexplode(defaclacl)).grantee,
            (aclexplode(defaclacl)).privilege_type
          FROM pg_catalog.pg_default_acl def
          JOIN pg_catalog.pg_namespace nsp ON nsp.oid = def.defaclnamespace
          WHERE defaclobjtype = 'r'
        ),
        nspacl AS (
          -- All namespace and role having grant on it, and array of available
          -- relations in the namespace.
          SELECT
            nsp.oid, nsp.nspname,
            (aclexplode(nspacl)).grantee,
            (aclexplode(nspacl)).privilege_type,
            ARRAY(SELECT UNNEST(array_agg(rel.relname)) ORDER BY 1) AS relname
          FROM pg_catalog.pg_namespace nsp
          LEFT OUTER JOIN pg_catalog.pg_class rel
            ON rel.relnamespace = nsp.oid AND relkind IN ('r', 'v')
          WHERE nsp.nspname NOT LIKE 'pg_%'
          GROUP BY 1, 2, 3, 4
        ),
        rel AS (
          -- All namespace, role and relation privilege granted to what relation
          -- in the namespace.
          SELECT
            table_schema as "schema",
            grantee, privilege_type,
            -- Aggregate the relation grant for this privilege.
            ARRAY(SELECT UNNEST(array_agg(table_name::name)) ORDER BY 1) as tables
          FROM information_schema.role_table_grants
          GROUP BY 1, 2, 3
        )

      -- Now list all users per schema who have USAGE or SELECT to any
      -- relations or have SELECT default privilege.
      SELECT
        nsp.nspname,
        rol.rolname,
        (
          nspacl.oid IS NOT NULL AND
          def.oid IS NOT NULL AND
          -- Here, compare arrays to ensure SELECT grant is for all relation in
          -- namespace.
          coalesce(select_.tables, ARRAY[NULL]::name[]) = nspacl.relname
        )
      FROM pg_catalog.pg_roles rol
      CROSS JOIN pg_catalog.pg_namespace nsp
      LEFT OUTER JOIN nspacl
        ON nspacl.grantee = rol.oid AND
           nspacl.oid = nsp.oid
      LEFT OUTER JOIN def
        ON def.grantee = rol.oid AND
           def.privilege_type = 'SELECT' AND
           def.oid = nsp.oid
      LEFT OUTER JOIN rel AS select_
        ON select_.privilege_type = 'SELECT' AND
           select_."schema" = nsp.nspname AND
           select_.grantee = rol.rolname
      WHERE nspacl.oid IS NOT NULL OR def.oid IS NOT NULL OR select_."schema" IS NOT NULL
      ORDER BY 1, 2;
    grant: |
      GRANT USAGE ON SCHEMA {schema} TO {role};
      GRANT SELECT ON ALL TABLES IN SCHEMA {schema} TO {role};
      ALTER DEFAULT PRIVILEGES IN SCHEMA {schema} GRANT SELECT ON TABLES TO {role};
    revoke: |
      ALTER DEFAULT PRIVILEGES IN SCHEMA {schema} REVOKE SELECT ON TABLES FROM {role};
      REVOKE SELECT ON ALL TABLES IN SCHEMA {schema} FROM {role};
      REVOKE USAGE ON SCHEMA {schema} FROM {role};

sync_map:
- grant:
    role: daniel
    acl: connect
    database: frontend
    schema: __any__
- grant:
    role: daniel
    acl: ro
    database: frontend
    schema: __all__
